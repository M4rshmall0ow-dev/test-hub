-- DAFORGE_GLOBAL.txt
-- Fully globalized version of your Forge script
-- All variables, functions, and modules are exposed under _G (no locals)

-- Services (global)
_G.Players = game:GetService("Players")
_G.ReplicatedStorage = game:GetService("ReplicatedStorage")
_G.Workspace = game:GetService("Workspace")
_G.TweenService = game:GetService("TweenService")
_G.HttpService = game:GetService("HttpService")

-- WindUI loader (best-effort)
local success_wind, WindUILib = pcall(function()
  return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)
if success_wind and WindUILib then
  _G.WindUI = WindUILib
else
  warn("Failed to load WindUI. WindUI will be nil.")
  _G.WindUI = nil
end

-- Utility: GradientText
_G.GradientText = function(text, color1, color2)
  if not text or #text == 0 then return "" end
  local result = ""
  for i = 1, #text do
    local t = 0
    if #text > 1 then
      t = (i - 1) / (#text - 1)
    end
    local r = color1.R + (color2.R - color1.R) * t
    local g = color1.G + (color2.G - color1.G) * t
    local b = color1.B + (color2.B - color1.B) * t
    local ri = math.floor(r * 255 + 0.5)
    local gi = math.floor(g * 255 + 0.5)
    local bi = math.floor(b * 255 + 0.5)
    local hex = string.format("#%02X%02X%02X", ri, gi, bi)
    result = result .. string.format('<font color="%s">%s</font>', hex, text:sub(i, i))
  end
  return result
end

-- Create Window if WindUI available
if _G.WindUI then
  _G.Window = _G.WindUI:CreateWindow({
    Title = _G.GradientText("PanScript", Color3.fromRGB(173,216,230), Color3.fromRGB(0,0,139)),
    Icon = "rbxassetid://84501312005643",
    IconThemed = true,
    Author = "By @mallo",
    Size = UDim2.fromOffset(580, 460),
    Resizable = true,
    Transparent = true,
    User = {
      Enabled = true,
      Anonymous = false,
      Callback = function()
        print("Window user callback")
      end,
    },
  })
  _G.Window:SetIconSize(50)
  _G.Window:EditOpenButton({
    Title = _G.GradientText("PanScript", Color3.fromRGB(173,216,230), Color3.fromRGB(0,0,139)),
    Icon = "rbxassetid://84501312005643",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromRGB(173,216,230), Color3.fromRGB(0,0,139)),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
  })
  _G.Window:DisableTopbarButtons({ "Close" })
else
  warn("WindUI missing â€” UI creation skipped.")
end

-- Tab setup (best-effort)
if _G.Window then
  _G.Tab = _G.Window:Tab({
    Title = "Vulnerability",
    Icon = "file-exclamation-point"
  })
end

-- Ore list
_G.OreTypes = { "Pebble", "Rock", "Boulder", "Basalt Rock", "Volcanic Rock" }

-- Default global settings
_G.AutoMine = _G.AutoMine or false
_G.MineTheseOres = _G.MineTheseOres or { "Pebble" }
_G.TweenSpeed = _G.TweenSpeed or 67
_G.LastNoOreNotify = _G.LastNoOreNotify or 0

-- Dropdown, toggles, sliders - create only if Tab exists
if _G.Tab then
  _G.Dropdown = _G.Tab:Dropdown({
    Title = "Ore Types",
    Desc = "Select one ore to mine",
    Values = _G.OreTypes,
    Value = "Pebble",
    Multi = false,
    AllowNone = false,
    Callback = function(selected)
      _G.MineTheseOres = { selected }
      print("Selected Ore:", selected)
    end
  })

  _G.Toggle = _G.Tab:Toggle({
      Title = "Auto Mine",
      Desc = "Automatically mines selected ores",
      Icon = "pickaxe",
      Type = "Checkbox",
      Value = false,
      Callback = function(state)
          _G.AutoMine = state
          print("Auto Mine:", state)
          if state then
              pcall(function()
                  _G.WindUI:Notify({
                      Title = "Auto Mine Enabled",
                      Content = "mining started",
                      Duration = 3,
                      Icon = "bird",
                  })
              end)
          end
      end
  })

  _G.Slider = _G.Tab:Slider({
      Title = "Tween Speed",
      Desc = "Adjust how fast the player moves to the ore",
      Step = 1,
      Value = { Min = 1, Max = 100, Default = _G.TweenSpeed },
      Callback = function(value)
          _G.TweenSpeed = value
          print("Tween Speed set to:", value)
      end
  })
end

-- safeRequire helper (exposed globally)
_G.safeRequire = function(name)
  local function tryGet(obj)
    if not obj then return nil end
    if typeof(obj) == "Instance" and obj:IsA("ModuleScript") then return obj end
    return nil
  end

  local places = {
    script,
    script.Parent,
    _G.ReplicatedStorage,
    game:GetService("ServerStorage"),
    _G.Workspace,
    game:GetService("StarterPlayer"),
  }

  for _, parent in ipairs(places) do
    if parent then
      local candidate = parent:FindFirstChild(name, true)
      if candidate and candidate:IsA("ModuleScript") then
        local ok, mod = pcall(require, candidate)
        if ok then return mod end
      end
    end
  end

  if _G[name] then
    local ok, val = pcall(function() return _G[name] end)
    if ok then return val end
  end

  warn("safeRequire: module '" .. tostring(name) .. "' not found in common locations.")
  return nil
end

-- Cache placeholders for modules (globals)
_G.AutoMinerModule = _G.AutoMinerModule
_G.AutoEquipModule = _G.AutoEquipModule
_G.OreESPModule = _G.OreESPModule
_G.TeleportModule = _G.TeleportModule
_G.StatAnalyzerModule = _G.StatAnalyzerModule
_G.InventoryCleanerModule = _G.InventoryCleanerModule
_G.QuickUIModule = _G.QuickUIModule

-- UI Buttons and Toggles (if Tab exists)
if _G.Tab then
  _G.AutoMinerToggle = _G.Tab:Toggle({
      Title = "AutoMiner",
      Desc = "Start/stop AutoMiner module (if installed)",
      Icon = "pickaxe",
      Type = "Checkbox",
      Value = false,
      Callback = function(state)
          if state then
              _G.AutoMinerModule = _G.AutoMinerModule or _G.safeRequire("AutoMiner") or _G.safeRequire("AutoMiner.lua")
              if _G.AutoMinerModule and _G.AutoMinerModule.StartLoop then
                  pcall(function() _G.AutoMinerModule.StartLoop() end)
                  print("AutoMiner started.")
              else
                  warn("AutoMiner module not found or StartLoop missing.")
              end
          else
              if _G.AutoMinerModule and _G.AutoMinerModule.StopLoop then
                  pcall(function() _G.AutoMinerModule.StopLoop() end)
                  print("AutoMiner stopped.")
              end
          end
      end
  })

  _G.EquipButton = _G.Tab:Button({
      Title = "Auto-Equip Best Pickaxe",
      Desc = "Equip the best pickaxe using data module (best-effort)",
      Locked = false,
      Callback = function()
          _G.AutoEquipModule = _G.AutoEquipModule or _G.safeRequire("AutoEquipBest") or _G.safeRequire("AutoEquipBest.lua")
          if _G.AutoEquipModule and _G.AutoEquipModule.AttemptEquipBest then
              pcall(function() _G.AutoEquipModule.AttemptEquipBest() end)
              print("Attempted auto-equip best pickaxe.")
          else
              warn("AutoEquip module not found.")
          end
      end
  })

  _G.ESPToggle = _G.Tab:Toggle({
      Title = "Ore ESP",
      Desc = "Highlight ores (uses OreESP module)",
      Icon = "search",
      Type = "Checkbox",
      Value = false,
      Callback = function(state)
          _G.OreESPModule = _G.OreESPModule or _G.safeRequire("OreESP") or _G.safeRequire("OreESP.lua")
          if not _G.OreESPModule then
              warn("OreESP module not found.")
              return
          end
          if state then
              pcall(function() _G.OreESPModule.ScanAndTag(function(model, base) return true end) end)
              print("Ore ESP enabled.")
          else
              pcall(function() _G.OreESPModule.ClearTags() end)
              print("Ore ESP disabled.")
          end
      end
  })

  -- Teleport dropdown
  _G.tpValues = { "Loading..." }
  _G.TeleportDropdown = _G.Tab:Dropdown({
      Title = "Teleports",
      Desc = "Select destination to teleport",
      Values = _G.tpValues,
      Value = { _G.tpValues[1] },
      Multi = false,
      AllowNone = false,
      Callback = function(selected)
          _G.TeleportModule = _G.TeleportModule or _G.safeRequire("TeleportMenu") or _G.safeRequire("TeleportMenu.lua")
          if _G.TeleportModule and _G.TeleportModule.TeleportTo then
              pcall(function() _G.TeleportModule.TeleportTo(selected) end)
              print("Teleported to:", selected)
          else
              warn("TeleportMenu module not found.")
          end
      end
  })

  -- populate teleport names if possible
  _G.TeleportModule = _G.TeleportModule or _G.safeRequire("TeleportMenu") or _G.safeRequire("TeleportMenu.lua")
  if _G.TeleportModule and _G.TeleportModule.List then
    local ok, list = pcall(function() return _G.TeleportModule.List() end)
    if ok and type(list) == "table" and #list > 0 then
      _G.TeleportDropdown:Refresh(list)
    end
  end

  _G.StatButton = _G.Tab:Button({
      Title = "Show Top Pickaxes",
      Desc = "Prints top pickaxes via StatAnalyzer",
      Locked = false,
      Callback = function()
          _G.StatAnalyzerModule = _G.StatAnalyzerModule or _G.safeRequire("StatAnalyzer") or _G.safeRequire("StatAnalyzer.lua")
          if _G.StatAnalyzerModule and _G.StatAnalyzerModule.PrintTopPickaxes then
              pcall(function() _G.StatAnalyzerModule.PrintTopPickaxes(6) end)
          else
              warn("StatAnalyzer module not found.")
          end
      end
  })

  _G.InvButton = _G.Tab:Button({
      Title = "List Trash Items",
      Desc = "Lists low-value items (does not delete)",
      Locked = false,
      Callback = function()
          _G.InventoryCleanerModule = _G.InventoryCleanerModule or _G.safeRequire("InventoryCleaner") or _G.safeRequire("InventoryCleaner.lua")
          if _G.InventoryCleanerModule and _G.InventoryCleanerModule.ListTrash then
              local ok, list = pcall(function() return _G.InventoryCleanerModule.ListTrash("Common") end)
              if ok then
                  print("InventoryCleaner candidates:", #list)
                  for i,item in ipairs(list) do
                      print(i, item.Name or item.GUID or tostring(item))
                  end
              else
                  warn("InventoryCleaner.ListTrash failed.")
              end
          else
              warn("InventoryCleaner module not found.")
          end
      end
  })

  _G.QuickInvButton = _G.Tab:Button({
      Title = "Quick Inventory UI",
      Desc = "Shows quick inventory UI (best-effort)",
      Locked = false,
      Callback = function()
          _G.QuickUIModule = _G.QuickUIModule or _G.safeRequire("QuickInventoryUI") or _G.safeRequire("QuickInventoryUI.lua")
          _G.StatAnalyzerModule = _G.StatAnalyzerModule or _G.safeRequire("StatAnalyzer") or _G.safeRequire("StatAnalyzer.lua")
          if _G.QuickUIModule and _G.QuickUIModule.ShowSimpleList and _G.StatAnalyzerModule and _G.StatAnalyzerModule.SummarizePickaxes then
              local ok, items = pcall(function() return _G.StatAnalyzerModule.SummarizePickaxes() end)
              if ok and type(items) == "table" then
                  local list = {}
                  for i=1, math.min(10, #items) do
                      table.insert(list, { name = items[i].name or ("Item"..i) })
                  end
                  pcall(function() _G.QuickUIModule.ShowSimpleList(list) end)
              end
          else
              warn("QuickInventoryUI or StatAnalyzer module missing.")
          end
      end
  })
end

-- ====== CORE AUTO MINER (merged global) ======
_G.Player = _G.Players.LocalPlayer
_G.RS = _G.ReplicatedStorage
_G.WorkspaceRef = _G.Workspace

-- MineRemote (best-effort)
pcall(function()
  if _G.RS and _G.RS:FindFirstChild("Shared") and _G.RS.Shared:FindFirstChild("Packages") then
    local ok, v = pcall(function()
      return _G.RS.Shared.Packages.Knit.Services.ToolService.RF.ToolActivated
    end)
    if ok and v then _G.MineRemote = v end
  end
end)

-- Rocks zone
if not _G.WorkspaceRef:FindFirstChild("Rocks") then
  warn("Workspace.Rocks not found - adjust zone names")
end
_G.Rocks = _G.WorkspaceRef:FindFirstChild("Rocks")

_G.safeWaitFor = function(name)
  if not _G.Rocks then return nil end
  local ok, res = pcall(function() return _G.Rocks:WaitForChild(name, 2) end)
  if ok then return res end
  return nil
end

-- Zones
_G.RockZones = _G.RockZones or {}
do
  local z1 = _G.safeWaitFor("Island1CaveStart")
  local z2 = _G.safeWaitFor("Island1CaveMid")
  local z3 = _G.safeWaitFor("Island1CaveDeep")
  if z1 then table.insert(_G.RockZones, z1) end
  if z2 then table.insert(_G.RockZones, z2) end
  if z3 then table.insert(_G.RockZones, z3) end
end

-- Character refs (use events)
if _G.Player then
  _G.Character = _G.Player.Character or _G.Player.CharacterAdded:Wait()
  _G.Root = _G.Character:WaitForChild("HumanoidRootPart")
  _G.Player.CharacterAdded:Connect(function()
    task.wait(0.5)
    _G.Character = _G.Player.Character
    _G.Root = _G.Character:WaitForChild("HumanoidRootPart")
  end)
else
  warn("Player not found (script may not be running in client context).")
end

_G.CurrentOre = nil
_G.LastTeleportedOre = nil
_G.TELEPORT_DISTANCE = 8

_G.GetBase = function(ore)
  if not ore then return nil end
  if ore:IsA("BasePart") then return ore end
  if ore.PrimaryPart then return ore.PrimaryPart end
  return ore:FindFirstChildWhichIsA("BasePart")
end

_G.OreHealth = function(ore)
  if not ore then return nil end
  local ok, hp = pcall(function() return ore:GetAttribute("Health") end)
  if ok and type(hp) == "number" then return hp end
  local base = _G.GetBase(ore)
  if base then
    local ok2, hp2 = pcall(function() return base:GetAttribute("Health") end)
    if ok2 and type(hp2) == "number" then return hp2 end
    local child = base:FindFirstChild("Health")
    if child and child.Value ~= nil then return tonumber(child.Value) end
  end
  local topchild = ore:FindFirstChild("Health")
  if topchild and topchild.Value ~= nil then return tonumber(topchild.Value) end
  return nil
end

_G.IsValidOre = function(ore)
  if not ore or not ore.Name then return false end
  for _, name in ipairs(_G.MineTheseOres or {}) do
    if string.find(string.lower(ore.Name), string.lower(name), 1, true) or string.find(string.lower(ore.Name), string.lower(name)) then
      return true
    end
  end
  return false
end

_G.GetClosestOre = function()
  local nearest, bestDist = nil, math.huge
  for _, zone in ipairs(_G.RockZones) do
    if not zone then
      -- skip
    else
      for _, cand in ipairs(zone:GetDescendants()) do
        if cand and (cand:IsA("Model") or cand:IsA("BasePart")) and _G.IsValidOre(cand) then
          local base = _G.GetBase(cand)
          if base then
            local hp = _G.OreHealth(cand)
            if hp and hp > 0 then
              local ok, pos = pcall(function() return _G.Root.Position end)
              if ok and pos then
                local d = (pos - base.Position).Magnitude
                if d < bestDist then
                  bestDist = d
                  nearest = cand
                end
              end
            end
          end
        end
      end
    end
  end
  return nearest
end

-- Freeze/unfreeze player
_G.FreezeActive = false
_G.SetFreeze = function(state)
    if _G.FreezeActive == state then return end
    _G.FreezeActive = state

    local Character = _G.Player and _G.Player.Character
    if not Character then return end
    local Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
    local Root = Character:FindFirstChild("HumanoidRootPart")

    if Humanoid and Root then
        if state then
            Humanoid.WalkSpeed = 0
            Humanoid.JumpPower = 0
            Humanoid.AutoRotate = false
        else
            Humanoid.WalkSpeed = 16
            Humanoid.JumpPower = 50
            Humanoid.AutoRotate = true
        end
    end
end

_G.SetNoclip = function(state)
    local Character = _G.Player and _G.Player.Character
    if not Character then return end
    for _, part in ipairs(Character:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide ~= nil then
            part.CanCollide = not state
        end
    end
end

_G.MoveToOre = function(ore)
    local base = _G.GetBase(ore)
    if not base then return end

    _G.SetNoclip(true)

    local offsetDistance = 5
    local directionToOre = (base.Position - _G.Root.Position).Unit
    local perpendicular = Vector3.new(-directionToOre.Z, 0, directionToOre.X)
    local sidePos = base.Position + perpendicular * offsetDistance

    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {_G.Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist

    local rayResult = workspace:Raycast(
        sidePos + Vector3.new(0, 10, 0),
        Vector3.new(0, -50, 0),
        rayParams
    )

    local finalY = sidePos.Y
    if rayResult then
        finalY = rayResult.Position.Y + 3
    end

    local targetPos = Vector3.new(sidePos.X, finalY, sidePos.Z)
    local goalCFrame = CFrame.new(targetPos, base.Position)

    local distance = (_G.Root.Position - targetPos).Magnitude
    local speed = _G.TweenSpeed or 67
    local tweenInfo = TweenInfo.new(distance / speed, Enum.EasingStyle.Linear)

    local tween = _G.TweenService:Create(_G.Root, tweenInfo, {CFrame = goalCFrame})
    tween:Play()
    tween.Completed:Wait()

    _G.SetNoclip(false)
end

_G.TeleportToOreOnce = function(ore)
    if not ore then return end
    if _G.LastTeleportedOre == ore then return end
    _G.MoveToOre(ore)
    _G.LastTeleportedOre = ore
end

_G.TryMineSafe = function()
  if not _G.MineRemote then
    pcall(function()
      local rr = _G.RS.Shared and _G.RS.Shared.Packages and _G.RS.Shared.Packages.Knit and _G.RS.Shared.Packages.Knit.Services and _G.RS.Shared.Packages.Knit.Services.ToolService and _G.RS.Shared.Packages.Knit.Services.ToolService.RF and _G.RS.Shared.Packages.Knit.Services.ToolService.RF.ToolActivated
      if rr then
        pcall(function() rr:InvokeServer("Pickaxe") end)
      end
    end)
    return
  end
  pcall(function() _G.MineRemote:InvokeServer("Pickaxe") end)
end

-- AUTO MINER loop
task.spawn(function()
    while true do
        task.wait(0.12)

        if not _G.AutoMine then
            _G.CurrentOre = nil
            _G.LastTeleportedOre = nil
            _G.SetFreeze(false)
        else
            if not (_G.Character and _G.Character.Parent and _G.Root and _G.Root.Parent) then
                task.wait(0.4)
                _G.Character = _G.Player.Character or _G.Player.CharacterAdded:Wait()
                _G.Root = _G.Character:FindFirstChild("HumanoidRootPart") or _G.Root
            end

            local hasValid = false
            if _G.CurrentOre and _G.CurrentOre.Parent then
                local hp = _G.OreHealth(_G.CurrentOre)
                if hp and hp > 0 then
                    hasValid = true
                else
                    _G.CurrentOre = nil
                    _G.LastTeleportedOre = nil
                end
            end

            if not hasValid then
                _G.CurrentOre = _G.GetClosestOre()
                _G.LastTeleportedOre = nil

                if not _G.CurrentOre then
                    local now = tick()
                    if now - _G.LastNoOreNotify > 3 then
                        _G.LastNoOreNotify = now
                        pcall(function()
                            if _G.WindUI then
                              _G.WindUI:Notify({
                                  Title = "No Ores Found",
                                  Content = "Selected ores are not nearby or do not exist.",
                                  Duration = 3,
                                  Icon = "alert-triangle",
                              })
                            end
                        end)
                    end
                end
            end

            if _G.CurrentOre then
                local base = _G.GetBase(_G.CurrentOre)
                if base then
                    local ok, rootPos = pcall(function() return _G.Root.Position end)
                    if ok and rootPos then
                        local dist = (rootPos - base.Position).Magnitude
                        if (not _G.LastTeleportedOre) or dist > _G.TELEPORT_DISTANCE then
                            _G.TeleportToOreOnce(_G.CurrentOre)
                            task.wait(0.12)
                        end
                    else
                        _G.TeleportToOreOnce(_G.CurrentOre)
                    end

                    _G.SetFreeze(true)
                    _G.TryMineSafe()
                    task.wait(0.05)

                    local hp = _G.OreHealth(_G.CurrentOre)
                    if not hp or hp <= 0 then
                        _G.CurrentOre = nil
                        _G.LastTeleportedOre = nil
                        _G.SetFreeze(false)
                    end
                else
                    _G.CurrentOre = nil
                    _G.LastTeleportedOre = nil
                    _G.SetFreeze(false)
                end
            else
                _G.SetFreeze(false)
            end
        end
    end
end)

-- ====== MODULES (merged globals) ======

-- AutoMiner module (exposed globally)
_G.AutoMiner = _G.AutoMiner or {}
do
  _G.AutoMiner.settings = {
    allowedRarities = { "Common", "Uncommon", "Rare", "Epic", "Legendary" },
    allowedNames = nil,
    speed = _G.TweenSpeed or 67,
    teleportDistance = _G.TELEPORT_DISTANCE or 8
  }

  _G.AutoMiner.isOreValid = function(model)
    if not model then return false end
    local name = model.Name or ""
    if _G.AutoMiner.settings.allowedNames then
      for _, n in pairs(_G.AutoMiner.settings.allowedNames) do
        if string.find(string.lower(name), string.lower(n), 1, true) then return true end
      end
      return false
    end
    local OreData = nil
    pcall(function() OreData = require(_G.RS.Shared.Data.Ore) end)
    if OreData and OreData[ name ] and OreData[name].Rarity then
      for _, r in ipairs(_G.AutoMiner.settings.allowedRarities) do
        if OreData[name].Rarity == r then return true end
      end
      return false
    end
    return string.find(string.lower(name), "rock") or string.find(string.lower(name), "pebble")
  end

  _G.AutoMiner.getBase = function(model)
    if model:IsA("BasePart") then return model end
    if model.PrimaryPart then return model.PrimaryPart end
    return model:FindFirstChildWhichIsA("BasePart")
  end

  _G.AutoMiner.getClosestOre = function()
    local rocks = _G.WorkspaceRef:FindFirstChild("Rocks")
    if not rocks then return nil end
    local best, bestd = nil, math.huge
    for _, zone in ipairs(rocks:GetDescendants()) do
      if zone and (zone:IsA("Model") or zone:IsA("BasePart")) and _G.AutoMiner.isOreValid(zone) then
        local base = _G.AutoMiner.getBase(zone)
        if base then
          local ok, pos = pcall(function() return _G.Player.Character and _G.Player.Character:FindFirstChild("HumanoidRootPart") and _G.Player.Character.HumanoidRootPart.Position end)
          if ok and pos then
            local d = (pos - base.Position).Magnitude
            if d < bestd then bestd, best = d, zone end
          end
        end
      end
    end
    return best
  end

  pcall(function()
    _G.AutoMiner.MineRemote = _G.RS.Shared and _G.RS.Shared.Packages and _G.RS.Shared.Packages.Knit and _G.RS.Shared.Packages.Knit.Services and _G.RS.Shared.Packages.Knit.Services.ToolService and _G.RS.Shared.Packages.Knit.Services.ToolService.RF and _G.RS.Shared.Packages.Knit.Services.ToolService.RF.ToolActivated
  end)

  _G.AutoMiner.moveToPosition = function(targetPos, speed)
    speed = speed or _G.AutoMiner.settings.speed or _G.TweenSpeed or 67
    local root = _G.Player.Character and _G.Player.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    local dt = 0.03
    while root and root.Parent do
      task.wait(dt)
      local cur = root.Position
      local dir = targetPos - cur
      local dist = dir.Magnitude
      if dist < 0.6 then break end
      local sp = math.max(1, speed)
      local move = math.min(sp * dt, dist)
      local newPos = cur + dir.Unit * move
      root.CFrame = CFrame.new(newPos, targetPos)
    end
  end

  _G.AutoMiner.tryMine = function()
    if _G.AutoMiner.MineRemote then
      pcall(function() _G.AutoMiner.MineRemote:InvokeServer("Pickaxe") end)
    else
      warn("AutoMiner: Mine remote not found.")
    end
  end

  _G.AutoMiner.running = false
  _G.AutoMiner.StartLoop = function()
    if _G.AutoMiner.running then return end
    _G.AutoMiner.running = true
    task.spawn(function()
      while _G.AutoMiner.running do
        task.wait(0.12)
        local ore = _G.AutoMiner.getClosestOre()
        if ore then
          local base = _G.AutoMiner.getBase(ore)
          if base then
            local perp = (base.Position - (_G.Player.Character and _G.Player.Character:FindFirstChild("HumanoidRootPart") and _G.Player.Character.HumanoidRootPart.Position or base.Position)).Unit
            perp = Vector3.new(-perp.Z,0,perp.X)
            local sidePos = base.Position + perp * 4
            local rayResult = workspace:Raycast(sidePos + Vector3.new(0,20,0), Vector3.new(0,-60,0), RaycastParams.new())
            local y = rayResult and rayResult.Position.Y + 3 or sidePos.Y
            _G.AutoMiner.moveToPosition(Vector3.new(sidePos.X, y, sidePos.Z))
            local root = _G.Player.Character and _G.Player.Character:FindFirstChild("HumanoidRootPart")
            if root then root.CFrame = CFrame.new(root.Position, base.Position) end
            _G.AutoMiner.tryMine()
            task.wait(0.06)
          end
        else
          task.wait(0.5)
        end
      end
    end)
  end

  _G.AutoMiner.StopLoop = function()
    _G.AutoMiner.running = false
  end
end

-- AutoEquip module
_G.AutoEquip = _G.AutoEquip or {}
do
  pcall(function() _G.AutoEquip.EquipData = require(_G.RS.Shared.Data.Equipments) end)
  _G.AutoEquip.GetBestPickaxe = function()
    if not _G.AutoEquip.EquipData then return nil end
    local best, bestV = nil, -math.huge
    for k,v in pairs(_G.AutoEquip.EquipData.Pickaxe or {}) do
      local power = v[5] or v["Mine Power"] or v[1] or 0
      if type(power) == "number" and power > bestV then bestV, best = power, {name = k, data = v} end
    end
    return best
  end

  _G.AutoEquip.AttemptEquipBest = function()
    local best = _G.AutoEquip.GetBestPickaxe()
    if not best then
      warn("AutoEquip: no pickaxe data found.")
      return
    end
    print("AutoEquip: Best pickaxe is", best.name)
    local Knit = nil
    pcall(function() Knit = require(_G.RS.Shared.Packages.Knit) end)
    local CharacterService = (Knit and (Knit.GetService and Knit.GetService("CharacterService") or Knit.GetController and Knit.GetController("CharacterController")))
    if CharacterService and CharacterService.EquipItem then
      task.spawn(function()
        local ok, res = pcall(function() return CharacterService:EquipItem(best.name) end)
        if not ok then warn("AutoEquip: CharacterService Equip failed") end
      end)
    else
      warn("AutoEquip: Can't access CharacterService. Suggest equipping:", best.name)
    end
  end
end

-- OreESP module
_G.OreESP = _G.OreESP or {}
do
  pcall(function() _G.OreESP.OreData = require(_G.RS.Shared.Data.Ore) end)
  _G.OreESP.ensureGuiFor = function(part, labelText, color)
    if not part or not part:IsA("BasePart") then return end
    if part:FindFirstChild("ESP_Tag") then return end
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_Tag"
    billboard.Adornee = part
    billboard.Size = UDim2.new(0,120,0,32)
    billboard.StudsOffset = Vector3.new(0,2,0)
    billboard.AlwaysOnTop = true
    local txt = Instance.new("TextLabel", billboard)
    txt.Size = UDim2.fromScale(1,1)
    txt.BackgroundTransparency = 1
    txt.TextScaled = true
    txt.Text = labelText or part.Name
    txt.TextColor3 = color or Color3.new(1,1,1)
    billboard.Parent = game:GetService("CoreGui") or _G.Player:WaitForChild("PlayerGui")
    return billboard
  end

  _G.OreESP.ScanAndTag = function(filterFn)
    filterFn = filterFn or function() return true end
    local rocks = _G.WorkspaceRef:FindFirstChild("Rocks")
    if not rocks then return end
    for _, zone in ipairs(rocks:GetDescendants()) do
      if zone and (zone:IsA("Model") or zone:IsA("BasePart")) then
        local base = zone:IsA("BasePart") and zone or zone:FindFirstChildWhichIsA("BasePart")
        if base and filterFn(zone, base) then
          local color = Color3.new(1,1,1)
          local name = zone.Name
          if _G.OreESP.OreData and _G.OreESP.OreData[name] and _G.OreESP.OreData[name].Slot and _G.OreESP.OreData[name].Slot.GlowColor then
            color = _G.OreESP.OreData[name].Slot.GlowColor
          end
          _G.OreESP.ensureGuiFor(base, name, color)
        end
      end
    end
  end

  _G.OreESP.ClearTags = function()
    for _, gui in ipairs((game:GetService("CoreGui") or _G.Player:WaitForChild("PlayerGui")):GetDescendants()) do
      if gui.Name == "ESP_Tag" then gui:Destroy() end
    end
  end
end

-- TeleportMenu module
_G.TeleportMenu = _G.TeleportMenu or {}
do
  pcall(function() _G.TeleportMenu.ReplicaData = require(_G.RS.Shared.Data.Replica) end)
  _G.TeleportMenu.Teleports = {
    Forge = Vector3.new(-191.95,29.66,171.78),
  }
  if _G.TeleportMenu.ReplicaData and _G.TeleportMenu.ReplicaData.Teleport and _G.TeleportMenu.ReplicaData.Teleport.Forge then
    _G.TeleportMenu.Teleports.Forge = _G.TeleportMenu.ReplicaData.Teleport.Forge[1]
  end

  _G.TeleportMenu.TeleportTo = function(name)
    local dest = _G.TeleportMenu.Teleports[name]
    if not dest then
      warn("TeleportMenu: unknown destination", name)
      return
    end
    local char = _G.Player and _G.Player.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
      char.HumanoidRootPart.CFrame = CFrame.new(dest + Vector3.new(0,3,0))
    end
  end

  _G.TeleportMenu.List = function()
    local t = {}
    for k,_ in pairs(_G.TeleportMenu.Teleports) do table.insert(t,k) end
    return t
  end
end

-- StatAnalyzer module
_G.StatAnalyzer = _G.StatAnalyzer or {}
do
  pcall(function() _G.StatAnalyzer.EquipData = require(_G.RS.Shared.Data.Equipments) end)
  _G.StatAnalyzer.SummarizePickaxes = function()
    if not _G.StatAnalyzer.EquipData then return nil end
    local out = {}
    for name, data in pairs(_G.StatAnalyzer.EquipData.Pickaxe or {}) do
      table.insert(out, {name = name, power = data[5] or data["Mine Power"] or 0, rarity = data[2] or "Unknown"})
    end
    table.sort(out, function(a,b) return (a.power or 0) > (b.power or 0) end)
    return out
  end

  _G.StatAnalyzer.PrintTopPickaxes = function(n)
    local tbl = _G.StatAnalyzer.SummarizePickaxes()
    for i=1, math.min(n or 5, #tbl) do
      print(i, tbl[i].name, "power:", tbl[i].power, "rarity:", tbl[i].rarity)
    end
  end
end

-- InventoryCleaner module
_G.InventoryCleaner = _G.InventoryCleaner or {}
do
  pcall(function() _G.InventoryCleaner.EquipData = require(_G.RS.Shared.Data.Equipments) end)
  _G.InventoryCleaner.ListTrash = function(thresholdRarity)
    thresholdRarity = thresholdRarity or "Common"
    local order = {Common=1, Uncommon=2, Rare=3, Epic=4, Legendary=5}
    local thr = order[thresholdRarity] or 1
    local Replica = nil
    pcall(function() Replica = require(_G.RS.Shared.Packages.Knit).GetController("PlayerController").Replica end)
    local inv = Replica and Replica.Data and Replica.Data.Inventory and Replica.Data.Inventory.Equipments or {}
    local candidates = {}
    for guid, item in pairs(inv) do
      local r = item.Rarity or "Common"
      if order[r] and order[r] <= thr then
        table.insert(candidates, item)
      end
    end
    return candidates
  end

  _G.InventoryCleaner.DeleteList = function(items)
    print("InventoryCleaner: items to delete:")
    for _,it in ipairs(items) do
      print(it.GUID or it.Name)
    end
    return true
  end
end

-- QuickInventoryUI module
_G.QuickInventoryUI = _G.QuickInventoryUI or {}
do
  local CharacterService = nil
  pcall(function()
    local Knit = require(_G.RS.Shared.Packages.Knit)
    CharacterService = Knit.GetService and Knit.GetService("CharacterService") or Knit.GetController and Knit.GetController("CharacterController")
  end)

  _G.QuickInventoryUI.ShowSimpleList = function(items)
    local pg = _G.Player:FindFirstChild("PlayerGui") or _G.Player:WaitForChild("PlayerGui")
    local screen = Instance.new("ScreenGui", pg)
    screen.Name = "QuickInvUI"
    local frame = Instance.new("Frame", screen)
    frame.Position = UDim2.new(0.02,0,0.2,0)
    frame.Size = UDim2.new(0,250,0,300)
    frame.BackgroundTransparency = 0.5
    local y = 8
    for i, it in ipairs(items) do
      local btn = Instance.new("TextButton", frame)
      btn.Text = it.name or it.GUID or tostring(i)
      btn.Size = UDim2.new(1, -12, 0, 28)
      btn.Position = UDim2.new(0,6,0,y)
      btn.MouseButton1Click:Connect(function()
        if CharacterService and CharacterService.EquipItem then
          pcall(function() CharacterService:EquipItem(it) end)
        else
          warn("QuickUI: can't auto-equip (CharacterService missing).")
        end
      end)
      y = y + 34
    end
  end
end

-- Script ready
print("DAFORGE_GLOBAL loaded. All main symbols are under _G. Example: _G.AutoMine, _G.AutoMiner, _G.AutoEquip, _G.TeleportMenu")
