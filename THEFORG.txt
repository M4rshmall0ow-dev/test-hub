-- Combined WindUI + Smart Auto-Miner (fixed)
-- Fixes: no `continue`, proper booleans, safe remote calls, notify on toggle, respawn safe

 success, WindUI = pcall(function()
  return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)

if not success or not WindUI then
  warn("Failed to load WindUI. Aborting UI creation.")
  return
end

-- Utility: safe gradient text generator
 function GradientText(text, color1, color2)
  if not text or #text == 0 then return "" end
   result = ""
  for i = 1, #text do
     t = 0
    if #text > 1 then
      t = (i - 1) / (#text - 1)
    end
    r = color1.R + (color2.R - color1.R) * t
     g = color1.G + (color2.G - color1.G) * t
     b = color1.B + (color2.B - color1.B) * t
     ri = math.floor(r * 255 + 0.5)
     gi = math.floor(g * 255 + 0.5)
     bi = math.floor(b * 255 + 0.5)
     hex = string.format("#%02X%02X%02X", ri, gi, bi)
    result = result .. string.format('<font color="%s">%s</font>', hex, text:sub(i, i))
  end
  return result
end

 Window = WindUI:CreateWindow({
  Title = GradientText("PanScript", Color3.fromRGB(173,216,230), Color3.fromRGB(0,0,139)),
  Icon = "rbxassetid://84501312005643",
  IconThemed = true,
  Author = "By @mallo",
  Size = UDim2.fromOffset(580, 460),
  Resizable = true,
  Transparent = true,
  User = {
    Enabled = true,
    Anonymous = false,
    Callback = function()
      print("Window user callback")
    end,
  },
})

Window:SetIconSize(50)

Window:EditOpenButton({
  Title = GradientText("PanScript", Color3.fromRGB(173,216,230), Color3.fromRGB(0,0,139)),
  Icon = "rbxassetid://84501312005643",
  CornerRadius = UDim.new(0,16),
  StrokeThickness = 2,
  Color = ColorSequence.new(Color3.fromRGB(173,216,230), Color3.fromRGB(0,0,139)),
  OnlyMobile = false,
  Enabled = true,
  Draggable = true,
})

Window:DisableTopbarButtons({ "Close" })

 Tab = Window:Tab({
  Title = "Vulnerability",
  Icon = "file-exclamation-point"
})

-- Ore list you provided
 OreTypes = { "Pebble", "Rock", "Boulder", "Basalt Rock", "Volcanic Rock" }

 HttpService = game:GetService("HttpService")

 Dropdown = Tab:Dropdown({
  Title = "Ore Types",
  Desc = "Select one ore to mine",
  Values = OreTypes,          -- your ore list
  Value = "Pebble",           -- default selected
  Multi = false,              -- single select
  AllowNone = false,          -- must select one
  Callback = function(selected)
    _G.MineTheseOres = { selected }  -- wrap in table to keep rest of script compatible
    print("Selected Ore:", selected)
  end
})

-- set default global selected list if not already set
_G.MineTheseOres = _G.MineTheseOres or { "Pebble" }
 LastNoOreNotify = 0

 Toggle = Tab:Toggle({
    Title = "Auto Mine",
    Desc = "Automatically mines selected ores",
    Icon = "pickaxe",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        _G.AutoMine = state
        print("Auto Mine:", state)
        if state then
            -- notify only when disabled
            pcall(function()
                WindUI:Notify({
                    Title = "Auto Mine Enabled",
                    Content = "mining started",
                    Duration = 3,
                    Icon = "bird",
                })
            end)
        end
    end
})

 Slider = Tab:Slider({
    Title = "Tween Speed",
    Desc = "Adjust how fast the player moves to the ore",
    
    Step = 1, -- increment step
    Value = {
        Min = 1,      -- minimum speed
        Max = 100,     -- maximum speed
        Default = 67,  -- starting value
    },
    Callback = function(value)
        _G.TweenSpeed = value  -- store in a global variable
        print("Tween Speed set to:", value)
    end
})

-- ===== Extra UI controls (AutoMiner, AutoEquip, ESP, Teleports, Tools) =====
-- safe require helper: try common locations for ModuleScripts
 function safeRequire(name)
     tried = {}
     function tryGet(obj)
        if not obj then return nil end
        if typeof(obj) == "Instance" and obj:IsA("ModuleScript") then return obj end
        return nil
    end

    -- places to look
     places = {
        script,                      -- same script folder
        script.Parent,               -- sibling folder
        game:GetService("ReplicatedStorage"),
        game:GetService("ServerStorage"),
        game:GetService("Workspace"),
        game:GetService("StarterPlayer"),
    }

    for _, parent in ipairs(places) do
        if parent then
             candidate = parent:FindFirstChild(name, true) -- recursive search
            if candidate and candidate:IsA("ModuleScript") then
                 ok, mod = pcall(require, candidate)
                if ok then return mod end
            end
        end
    end

    -- also try global _G (in case modules were preloaded)
    if _G[name] then
         ok, val = pcall(function() return _G[name] end)
        if ok then return val end
    end

    warn("safeRequire: module '" .. tostring(name) .. "' not found in common locations.")
    return nil
end

-- cached module references (will be looked up when toggles/buttons used)
 AutoMinerModule, AutoEquipModule, OreESPModule, TeleportModule, StatAnalyzerModule, InventoryCleanerModule, QuickUIModule

-- AutoMiner toggle
 AutoMinerToggle = Tab:Toggle({
    Title = "AutoMiner",
    Desc = "Start/stop AutoMiner module (if installed)",
    Icon = "pickaxe",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        if state then
            AutoMinerModule = AutoMinerModule or safeRequire("AutoMiner") or safeRequire("AutoMiner.lua")
            if AutoMinerModule and AutoMinerModule.StartLoop then
                pcall(function() AutoMinerModule.StartLoop() end)
                print("AutoMiner started.")
            else
                warn("AutoMiner module not found or StartLoop missing.")
            end
        else
            if AutoMinerModule and AutoMinerModule.StopLoop then
                pcall(function() AutoMinerModule.StopLoop() end)
                print("AutoMiner stopped.")
            end
        end
    end
})

-- Auto-equip best pickaxe button
 EquipButton = Tab:Button({
    Title = "Auto-Equip Best Pickaxe",
    Desc = "Equip the best pickaxe using data module (best-effort)",
    Locked = false,
    Callback = function()
        AutoEquipModule = AutoEquipModule or safeRequire("AutoEquipBest") or safeRequire("AutoEquipBest.lua")
        if AutoEquipModule and AutoEquipModule.AttemptEquipBest then
            pcall(function() AutoEquipModule.AttemptEquipBest() end)
            print("Attempted auto-equip best pickaxe.")
        else
            warn("AutoEquip module not found.")
        end
    end
})

-- Ore ESP toggle
 ESPtoggle = Tab:Toggle({
    Title = "Ore ESP",
    Desc = "Highlight ores (uses OreESP module)",
    Icon = "search",
    Type = "Checkbox",
    Value = false,
    Callback = function(state)
        OreESPModule = OreESPModule or safeRequire("OreESP") or safeRequire("OreESP.lua")
        if not OreESPModule then
            warn("OreESP module not found.")
            return
        end
        if state then
            pcall(function() OreESPModule.ScanAndTag(function(model, base)
                -- default filter: show everything; user can modify module or replace with custom filter
                return true
            end) end)
            print("Ore ESP enabled.")
        else
            pcall(function() OreESPModule.ClearTags() end)
            print("Ore ESP disabled.")
        end
    end
})

-- Teleport dropdown + button: populate values from TeleportMenu.List()
 tpValues = { "Loading..." }
 TeleportDropdown = Tab:Dropdown({
    Title = "Teleports",
    Desc = "Select destination to teleport",
    Values = tpValues,
    Value = { tpValues[1] },
    Multi = false,
    AllowNone = false,
    Callback = function(selected)
        -- on select, attempt teleport
        TeleportModule = TeleportModule or safeRequire("TeleportMenu") or safeRequire("TeleportMenu.lua")
        if TeleportModule and TeleportModule.TeleportTo then
            pcall(function() TeleportModule.TeleportTo(selected) end)
            print("Teleported to:", selected)
        else
            warn("TeleportMenu module not found.")
        end
    end
})

-- populate teleport names (attempt)
do
    TeleportModule = TeleportModule or safeRequire("TeleportMenu") or safeRequire("TeleportMenu.lua")
    if TeleportModule and TeleportModule.List then
         ok, list = pcall(function() return TeleportModule.List() end)
        if ok and type(list) == "table" and #list > 0 then
            TeleportDropdown:Refresh(list)
        end
    end
end

-- Stat analyzer button (print top pickaxes)
 StatButton = Tab:Button({
    Title = "Show Top Pickaxes",
    Desc = "Prints top pickaxes via StatAnalyzer",
    Locked = false,
    Callback = function()
        StatAnalyzerModule = StatAnalyzerModule or safeRequire("StatAnalyzer") or safeRequire("StatAnalyzer.lua")
        if StatAnalyzerModule and StatAnalyzerModule.PrintTopPickaxes then
            pcall(function() StatAnalyzerModule.PrintTopPickaxes(6) end)
        else
            warn("StatAnalyzer module not found.")
        end
    end
})

-- Inventory cleaner (list only)
 InvButton = Tab:Button({
    Title = "List Trash Items",
    Desc = "Lists low-value items (does not delete)",
    Locked = false,
    Callback = function()
        InventoryCleanerModule = InventoryCleanerModule or safeRequire("InventoryCleaner") or safeRequire("InventoryCleaner.lua")
        if InventoryCleanerModule and InventoryCleanerModule.ListTrash then
             ok, list = pcall(function() return InventoryCleanerModule.ListTrash("Common") end)
            if ok then
                print("InventoryCleaner candidates:", #list)
                for i,item in ipairs(list) do
                    print(i, item.Name or item.GUID or tostring(item))
                end
            else
                warn("InventoryCleaner.ListTrash failed.")
            end
        else
            warn("InventoryCleaner module not found.")
        end
    end
})

-- Quick Inventory UI button
 QuickInvButton = Tab:Button({
    Title = "Quick Inventory UI",
    Desc = "Shows quick inventory UI (best-effort)",
    Locked = false,
    Callback = function()
        QuickUIModule = QuickUIModule or safeRequire("QuickInventoryUI") or safeRequire("QuickInventoryUI.lua")
        StatAnalyzerModule = StatAnalyzerModule or safeRequire("StatAnalyzer") or safeRequire("StatAnalyzer.lua")
        if QuickUIModule and QuickUIModule.ShowSimpleList and StatAnalyzerModule and StatAnalyzerModule.SummarizePickaxes then
             ok, items = pcall(function() return StatAnalyzerModule.SummarizePickaxes() end)
            if ok and type(items) == "table" then
                -- convert to simple list of {name=}
                 list = {}
                for i=1, math.min(10, #items) do
                    table.insert(list, { name = items[i].name or ("Item"..i) })
                end
                pcall(function() QuickUIModule.ShowSimpleList(list) end)
            end
        else
            warn("QuickInventoryUI or StatAnalyzer module missing.")
        end
    end
})

-- ======= AUTO MINER =======
 Players = game:GetService("Players")
 RS = game:GetService("ReplicatedStorage")
 Workspace = game:GetService("Workspace")
 LocalPlayer = Players.LocalPlayer
 TweenService = game:GetService("TweenService")

-- safe attempt to get remote; don't error if not found
 MineRemote
pcall(function()
  if RS and RS:FindFirstChild("Shared") and RS.Shared:FindFirstChild("Packages") then
     ok, v = pcall(function()
      return RS.Shared.Packages.Knit.Services.ToolService.RF.ToolActivated
    end)
    if ok and v then MineRemote = v end
  end
end)

_G.AutoMine = _G.AutoMine or false
_G.MineTheseOres = _G.MineTheseOres or { "Pebble" }

-- Zones: adjust names if needed
if not Workspace:FindFirstChild("Rocks") then
  warn("Workspace.Rocks not found - adjust zone names")
end
 Rocks = Workspace:FindFirstChild("Rocks")
 function safeWaitFor(name)
  if not Rocks then return nil end
   ok, res = pcall(function() return Rocks:WaitForChild(name, 2) end)
  if ok then return res end
  return nil
end

 RockZones = {}
do
   z1 = safeWaitFor("Island1CaveStart")
  l z2 = safeWaitFor("Island1CaveMid")
  l z3 = safeWaitFor("Island1CaveDeep")
  if z1 then table.insert(RockZones, z1) end
  if z2 then table.insert(RockZones, z2) end
  if z3 then table.insert(RockZones, z3) end
end

Character = Player.Character or Player.CharacterAdded:Wait()
Root = Character:WaitForChild("HumanoidRootPart")

Player.CharacterAdded:Connect(function()
  task.wait(0.5)
  Character = Player.Character
  Root = Character:WaitForChild("HumanoidRootPart")
end)

CurrentOre = nil
 LastTeleportedOre = nil
TELEPORT_DISTANCE = 8 -- if you move farther than this, tp back

 function GetBase(ore)
  if not ore then return nil end
  if ore:IsA("BasePart") then return ore end
  if ore.PrimaryPart then return ore.PrimaryPart end
  return ore:FindFirstChildWhichIsA("BasePart")
end

 function OreHealth(ore)
  if not ore then return nil end
   ok, hp = pcall(function() return ore:GetAttribute("Health") end)
  if ok and type(hp) == "number" then return hp end
   base = GetBase(ore)
  if base then
     ok2, hp2 = pcall(function() return base:GetAttribute("Health") end)
    if ok2 and type(hp2) == "number" then return hp2 end
     child = base:FindFirstChild("Health")
    if child and child.Value ~= nil then return tonumber(child.Value) end
  end
   topchild = ore:FindFirstChild("Health")
  if topchild and topchild.Value ~= nil then return tonumber(topchild.Value) end
  return nil
end

 function IsValidOre(ore)
  if not ore or not ore.Name then return false end
  for _, name in ipairs(_G.MineTheseOres or {}) do
    if string.find(string.lower(ore.Name), string.lower(name), 1, true) or string.find(string.lower(ore.Name), string.lower(name)) then
      return true
    end
  end
  return false
end

 function GetClosestOre()
   nearest, bestDist = nil, math.huge
  for _, zone in ipairs(RockZones) do
    if not zone then
      -- skip missing zone
    else
      for _, cand in ipairs(zone:GetDescendants()) do
        if cand and (cand:IsA("Model") or cand:IsA("BasePart")) and IsValidOre(cand) then
           base = GetBase(cand)
          if base then
             hp = OreHealth(cand)
            if hp and hp > 0 then
               ok, pos = pcall(function() return Root.Position end)
              if ok and pos then
                 d = (pos - base.Position).Magnitude
                if d < bestDist then
                  bestDist = d
                  nearest = cand
                end
              end
            end
          end
        end
      end
    end
  end
  return nearest
end

-- 1️⃣ Freeze/unfreeze player
 FreezeActive = false
 function SetFreeze(state)
    if FreezeActive == state then return end
    FreezeActive = state

     Character = Player.Character
    if not Character then return end
     Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
     Root = Character:FindFirstChild("HumanoidRootPart")

    if Humanoid and Root then
        if state then
            -- Freeze movement but DO NOT anchor Root!
            Humanoid.WalkSpeed = 0
            Humanoid.JumpPower = 0
            Humanoid.AutoRotate = false
        else
            -- Restore normal movement
            Humanoid.WalkSpeed = 16
            Humanoid.JumpPower = 50
            Humanoid.AutoRotate = true
        end
    end
end

-- updates freeze based on current ore and AutoMine toggle
 function UpdateFreeze()
    if _G.AutoMine and CurrentOre then
        SetFreeze(true)   -- freeze only while auto-mining a valid ore
    else
        SetFreeze(false)  -- unfreeze otherwise
    end
end

 function SetNoclip(state)
     Character = Player.Character
    if not Character then return end
    for _, part in ipairs(Character:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide ~= nil then
            part.CanCollide = not state
        end
    end
end

 TweenService = game:GetService("TweenService")

 function MoveToOre(ore)
     base = GetBase(ore)
    if not base then return end

    SetNoclip(true)

    -- side offset
     offsetDistance = 5
     directionToOre = (base.Position - Root.Position).Unit
     perpendicular = Vector3.new(-directionToOre.Z, 0, directionToOre.X)
     sidePos = base.Position + perpendicular * offsetDistance

    -- RAYCAST DOWN TO FIND REAL GROUND HEIGHT
     rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist

     rayResult = workspace:Raycast(
        sidePos + Vector3.new(0, 10, 0),  -- start above
        Vector3.new(0, -50, 0),          -- cast downward
        rayParams
    )

     finalY = sidePos.Y
    if rayResult then
        finalY = rayResult.Position.Y + 3 -- put feet exactly above ground
    end

     targetPos = Vector3.new(sidePos.X, finalY, sidePos.Z)

    -- FACE THE ORE
    local goalCFrame = CFrame.new(targetPos, base.Position)

    local distance = (Root.Position - targetPos).Magnitude
    local speed = _G.TweenSpeed or 67
    local tweenInfo = TweenInfo.new(distance / speed, Enum.EasingStyle.Linear)

    local tween = TweenService:Create(Root, tweenInfo, {CFrame = goalCFrame})
    tween:Play()
    tween.Completed:Wait()

    SetNoclip(false)
end

local function TeleportToOreOnce(ore)
    if not ore then return end
    if LastTeleportedOre == ore then return end
    MoveToOre(ore)
    LastTeleportedOre = ore
end

local function TryMineSafe()
  if not MineRemote then
    -- remote not found; attempt to call via path just-in-time (best-effort)
    pcall(function()
      local rr = RS.Shared and RS.Shared.Packages and RS.Shared.Packages.Knit and RS.Shared.Packages.Knit.Services and RS.Shared.Packages.Knit.Services.ToolService and RS.Shared.Packages.Knit.Services.ToolService.RF and RS.Shared.Packages.Knit.Services.ToolService.RF.ToolActivated
      if rr then
        pcall(function() rr:InvokeServer("Pickaxe") end)
      end
    end)
    return
  end
  pcall(function() MineRemote:InvokeServer("Pickaxe") end)
end

-- Main loop (no 'continue', compatible with all runtimes)
task.spawn(function()
    while true do
        task.wait(0.12)

        -- AutoMine off → reset
        if not _G.AutoMine then
            CurrentOre = nil
            LastTeleportedOre = nil
            SetFreeze(false)  -- ensure unfreeze
        else
            -- ensure character exists
            if not (Character and Character.Parent and Root and Root.Parent) then
                task.wait(0.4)
                Character = Player.Character or Player.CharacterAdded:Wait()
                Root = Character:FindFirstChild("HumanoidRootPart") or Root
            end

            -- validate current ore
            local hasValid = false
            if CurrentOre and CurrentOre.Parent then
                local hp = OreHealth(CurrentOre)
                if hp and hp > 0 then
                    hasValid = true
                else
                    CurrentOre = nil
                    LastTeleportedOre = nil
                end
            end

            if not hasValid then
                CurrentOre = GetClosestOre()
                LastTeleportedOre = nil

                -- Notify if no ore
                if not CurrentOre then
                    local now = tick()
                    if now - LastNoOreNotify > 3 then
                        LastNoOreNotify = now
                        pcall(function()
                            WindUI:Notify({
                                Title = "No Ores Found",
                                Content = "Selected ores are not nearby or do not exist.",
                                Duration = 3,
                                Icon = "alert-triangle",
                            })
                        end)
                    end
                end
            end

            -- if there is a valid ore
            if CurrentOre then
                local base = GetBase(CurrentOre)
                if base then
                    -- teleport/move to ore if needed
                    local ok, rootPos = pcall(function() return Root.Position end)
                    if ok and rootPos then
                        local dist = (rootPos - base.Position).Magnitude
                        if (not LastTeleportedOre) or dist > TELEPORT_DISTANCE then
                            TeleportToOreOnce(CurrentOre)
                            task.wait(0.12) -- small wait after teleport
                        end
                    else
                        TeleportToOreOnce(CurrentOre)
                    end

                    -- Freeze player while moving and mining
                    SetFreeze(true)

                    -- Mine
                    TryMineSafe()
                    task.wait(0.05)

                    -- Unfreeze automatically if AutoMine is off or ore is gone
                    local hp = OreHealth(CurrentOre)
                    if not hp or hp <= 0 then
                  
      CurrentOre = nil
                        LastTeleportedOre = nil
                        SetFreeze(false)
                    end
                else
                    CurrentOre = nil
                    LastTeleportedOre = nil
                    SetFreeze(false)
                end
            else
                SetFreeze(false) -- no ore → unfreeze
            end
        end
    end
end)

-- Module: AutoMiner.lua
local AutoMiner = {}
local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Player = Players.LocalPlayer

-- require ore data if available (decompiled file shows this exists). :contentReference[oaicite:1]{index=1}
local OreData
pcall(function() OreData = require(RS.Shared.Data.Ore) end)

-- settings
AutoMiner.settings = {
  allowedRarities = { "Common", "Uncommon", "Rare", "Epic", "Legendary" }, -- default all
  allowedNames = nil, -- table of strings to restrict by name (nil = any)
  speed = 67,
  teleportDistance = 8
}

local function isOreValid(model)
  if not model then return false end
  local name = model.Name or ""
  if AutoMiner.settings.allowedNames then
    for _, n in pairs(AutoMiner.settings.allowedNames) do
      if string.find(string.lower(name), string.lower(n), 1, true) then return true end
    end
    return false
  end
  -- try to decide rarity from OreData if present
  if OreData and OreData[ name ] and OreData[name].Rarity then
    for _, r in ipairs(AutoMiner.settings.allowedRarities) do
      if OreData[name].Rarity == r then return true end
    end
    return false
  end
  -- fallback: accept by name matching common ore words
  return string.find(string.lower(name), "rock") or string.find(string.lower(name), "pebble")
end

local function getBase(model)
  if model:IsA("BasePart") then return model end
  if model.PrimaryPart then return model.PrimaryPart end
  return model:FindFirstChildWhichIsA("BasePart")
end

local function getClosestOre()
  local rocks = Workspace:FindFirstChild("Rocks")
  if not rocks then return nil end
  local best, bestd = nil, math.huge
  for _, zone in ipairs(rocks:GetDescendants()) do
    if zone and (zone:IsA("Model") or zone:IsA("BasePart")) and isOreValid(zone) then
      local base = getBase(zone)
      if base then
        local ok, pos = pcall(function() return Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") and Player.Character.HumanoidRootPart.Position end)
        if ok and pos then
          local d = (pos - base.Position).Magnitude
          if d < bestd then bestd, best = d, zone end
        end
      end
    end
  end
  return best
end

-- best-effort mine remote (same pattern you used earlier)
local MineRemote
pcall(function()
  MineRemote = RS.Shared and RS.Shared.Packages and RS.Shared.Packages.Knit and RS.Shared.Packages.Knit.Services and RS.Shared.Packages.Knit.Services.ToolService and RS.Shared.Packages.Knit.Services.ToolService.RF and RS.Shared.Packages.Knit.Services.ToolService.RF.ToolActivated
end)

local TweenService = game:GetService("TweenService")

local function moveToPosition(targetPos, speed)
  -- simple, non-anchoring smooth move (reads speed each loop so slider affects it live)
  speed = speed or AutoMiner.settings.speed or 67
  local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
  if not root then return end
  local dt = 0.03
  while root and root.Parent do
    task.wait(dt)
    local cur = root.Position
    local dir = targetPos - cur
    local dist = dir.Magnitude
    if dist < 0.6 then break end
    local sp = math.max(1, speed)
    local move = math.min(sp * dt, dist)
    local newPos = cur + dir.Unit * move
    root.CFrame = CFrame.new(newPos, targetPos)
  end
end

local function tryMine()
  if MineRemote then
    pcall(function() MineRemote:InvokeServer("Pickaxe") end)
  else
    -- fallback brute force if unavailable (no-op)
    -- print so user knows
    warn("AutoMiner: Mine remote not found.")
  end
end

local running = false
function AutoMiner.StartLoop()
  if running then return end
  running = true
  task.spawn(function()
    while running do
      task.wait(0.12)
      local ore = getClosestOre()
      if ore then
        local base = getBase(ore)
        if base then
          -- calculate side position and ground raycast to stand beside and face ore
          local perp = (base.Position - (Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") and Player.Character.HumanoidRootPart.Position or base.Position)).Unit
          perp = Vector3.new(-perp.Z,0,perp.X)
          local sidePos = base.Position + perp * 4
          -- ray down to get ground
          local rayResult = workspace:Raycast(sidePos + Vector3.new(0,20,0), Vector3.new(0,-60,0), RaycastParams.new())
          local y = rayResult and rayResult.Position.Y + 3 or sidePos.Y
          moveToPosition(Vector3.new(sidePos.X, y, sidePos.Z))
          -- face ore
          local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
          if root then root.CFrame = CFrame.new(root.Position, base.Position) end
          -- try mine
          tryMine()
          task.wait(0.06)
        end
      else
        task.wait(0.5)
      end
    end
  end)
end

function AutoMiner.StopLoop()
  running = false
end

return AutoMiner

-- Module: AutoEquipBest.lua
local AutoEquip = {}
local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local Player = Players.LocalPlayer

local EquipData
pcall(function() EquipData = require(RS.Shared.Data.Equipments) end) -- decompiled file shows Equipments data. :contentReference[oaicite:2]{index=2}

-- try to get CharacterService via Knit if present
local Knit
local CharacterService
pcall(function()
  Knit = require(RS.Shared.Packages.Knit)
  CharacterService = Knit.GetService and Knit.GetService("CharacterService") or Knit.GetController and Knit.GetController("CharacterController")
end)

-- returns best pickaxe entry from data (best "Mine Power" or similar)
function AutoEquip.GetBestPickaxe()
  if not EquipData then return nil end
  local best, bestV = nil, -math.huge
  for k,v in pairs(EquipData.Pickaxe or {}) do
    local power = v[5] or v["Mine Power"] or v[1] or 0
    if type(power) == "number" and power > bestV then bestV, best = power, {name = k, data = v} end
  end
  return best
end

function AutoEquip.AttemptEquipBest()
  local best = AutoEquip.GetBestPickaxe()
  if not best then
    warn("AutoEquip: no pickaxe data found.")
    return
  end
  print("AutoEquip: Best pickaxe is", best.name)
  if CharacterService and CharacterService.EquipItem then
    task.spawn(function()
      local ok, res = pcall(function() return CharacterService:EquipItem(best.name) end)
      if not ok then warn("AutoEquip: CharacterService Equip failed") end
    end)
  else
    -- fallback: notify player (can't auto-equip)
    warn("AutoEquip: Can't access CharacterService. Suggest equipping:", best.name)
  end
end

return AutoEquip

-- Module: OreESP.lua
local OreESP = {}
local Workspace = game:GetService("Workspace")
local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local OreData
pcall(function() OreData = require(RS.Shared.Data.Ore) end)

local function ensureGuiFor(part, labelText, color)
  if not part or not part:IsA("BasePart") then return end
  if part:FindFirstChild("ESP_Tag") then return end
  local billboard = Instance.new("BillboardGui")
  billboard.Name = "ESP_Tag"
  billboard.Adornee = part
  billboard.Size = UDim2.new(0,120,0,32)
  billboard.StudsOffset = Vector3.new(0,2,0)
  billboard.AlwaysOnTop = true
  local txt = Instance.new("TextLabel", billboard)
  txt.Size = UDim2.fromScale(1,1)
  txt.BackgroundTransparency = 1
  txt.TextScaled = true
  txt.Text = labelText or part.Name
  txt.TextColor3 = color or Color3.new(1,1,1)
  billboard.Parent = game:GetService("CoreGui") or Player:WaitForChild("PlayerGui")
  return billboard
end

function OreESP.ScanAndTag(filterFn)
  filterFn = filterFn or function() return true end
  local rocks = Workspace:FindFirstChild("Rocks")
  if not rocks then return end
  for _, zone in ipairs(rocks:GetDescendants()) do
    if zone and (zone:IsA("Model") or zone:IsA("BasePart")) then
      local base = zone:IsA("BasePart") and zone or zone:FindFirstChildWhichIsA("BasePart")
      if base and filterFn(zone, base) then
        local color = Color3.new(1,1,1)
        local name = zone.Name
        if OreData and OreData[name] and OreData[name].Slot and OreData[name].Slot.GlowColor then
          color = OreData[name].Slot.GlowColor
        end
        ensureGuiFor(base, name, color)
      end
    end
  end
end

function OreESP.ClearTags()
  for _, gui in ipairs((game:GetService("CoreGui") or Player:WaitForChild("PlayerGui")):GetDescendants()) do
    if gui.Name == "ESP_Tag" then gui:Destroy() end
  end
end

return OreESP

-- Module: TeleportMenu.lua
local TeleportMenu = {}
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local RS = game:GetService("ReplicatedStorage")

-- attempt to read coordinate list from Replica (decompile shows a table)
local ReplicaData
pcall(function() ReplicaData = require(RS.Shared.Data.Replica) end) -- may not exist; safe fail

-- fallback small table (example from file)
local Teleports = {
  Forge = Vector3.new(-191.95,29.66,171.78),
  -- add more if you want
}

-- override from Replica if present
if ReplicaData and ReplicaData.Teleport and ReplicaData.Teleport.Forge then
  Teleports.Forge = ReplicaData.Teleport.Forge[1]
end

function TeleportMenu.TeleportTo(name)
  local dest = Teleports[name]
  if not dest then
    warn("TeleportMenu: unknown destination", name)
    return
  end
  local char = Player.Character
  if char and char:FindFirstChild("HumanoidRootPart") then
    char.HumanoidRootPart.CFrame = CFrame.new(dest + Vector3.new(0,3,0))
  end
end

function TeleportMenu.List()
  local t = {}
  for k,_ in pairs(Teleports) do table.insert(t,k) end
  return t
end

return TeleportMenu

-- Module: StatAnalyzer.lua
local StatAnalyzer = {}
local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local EquipData
pcall(function() EquipData = require(RS.Shared.Data.Equipments) end)

function StatAnalyzer.SummarizePickaxes()
  if not EquipData then return nil end
  local out = {}
  for name, data in pairs(EquipData.Pickaxe or {}) do
    table.insert(out, {name = name, power = data[5] or data["Mine Power"] or 0, rarity = data[2] or "Unknown"})
  end
  table.sort(out, function(a,b) return (a.power or 0) > (b.power or 0) end)
  return out
end

-- pretty print example:
function StatAnalyzer.PrintTopPickaxes(n)
  local tbl = StatAnalyzer.SummarizePickaxes()
  for i=1, math.min(n or 5, #tbl) do
    print(i, tbl[i].name, "power:", tbl[i].power, "rarity:", tbl[i].rarity)
  end
end

return StatAnalyzer

-- Module: InventoryCleaner.lua
local InventoryCleaner = {}
local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local EquipData
pcall(function() EquipData = require(RS.Shared.Data.Equipments) end)

-- Listing function: returns candidate items to remove based on thresholds
function InventoryCleaner.ListTrash(thresholdRarity)
  thresholdRarity = thresholdRarity or "Common"
  -- mapping rarity order
  local order = {Common=1, Uncommon=2, Rare=3, Epic=4, Legendary=5}
  local thr = order[thresholdRarity] or 1
  -- This code expects you have player inventory data: try Replica path if available
  local Replica
  pcall(function() Replica = require(RS.Shared.Packages.Knit).GetController("PlayerController").Replica end)
  local inv = Replica and Replica.Data and Replica.Data.Inventory and Replica.Data.Inventory.Equipments or {}
  local candidates = {}
  for guid, item in pairs(inv) do
    local r = item.Rarity or "Common"
    if order[r] and order[r] <= thr then
      table.insert(candidates, item)
    end
  end
  return candidates
end

-- Confirmed delete function: DOES NOT run automatically (you must call it and pass the items)
function InventoryCleaner.DeleteList(items)
  -- IMPORTANT: we do NOT auto-call remote here. You must adapt to your game's delete API.
  print("InventoryCleaner: items to delete:")
  for _,it in ipairs(items) do
    print(it.GUID or it.Name)
  end
  -- return true so caller can attempt to delete using the game's API if they want
  return true
end

return InventoryCleaner

-- Module: QuickInventoryUI.lua
local QuickUI = {}
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local RS = game:GetService("ReplicatedStorage")

local CharacterService
pcall(function()
  local Knit = require(RS.Shared.Packages.Knit)
  CharacterService = Knit.GetService and Knit.GetService("CharacterService") or Knit.GetController and Knit.GetController("CharacterController")
end)

function QuickUI.ShowSimpleList(items) -- items = list of {name=, guid=}
  -- create ScreenGui in PlayerGui
  local pg = Player:FindFirstChild("PlayerGui") or Player:WaitForChild("PlayerGui")
  local screen = Instance.new("ScreenGui", pg)
  screen.Name = "QuickInvUI"
  local frame = Instance.new("Frame", screen)
  frame.Position = UDim2.new(0.02,0,0.2,0)
  frame.Size = UDim2.new(0,250,0,300)
  frame.BackgroundTransparency = 0.5
  local y = 8
  for i, it in ipairs(items) do
    local btn = Instance.new("TextButton", frame)
    btn.Text = it.name or it.GUID or tostring(i)
    btn.Size = UDim2.new(1, -12, 0, 28)
    btn.Position = UDim2.new(0,6,0,y)
    btn.MouseButton1Click:Connect(function()
      if CharacterService and CharacterService.EquipItem then
        pcall(function() CharacterService:EquipItem(it) end)
      else
        warn("QuickUI: can't auto-equip (CharacterService missing).")
      end
    end)
    y = y + 34
  end
end

return QuickUI